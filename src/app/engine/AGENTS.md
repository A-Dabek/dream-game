# Engine Module - Agent Documentation

## Overview

The core game engine that manages the game state and flow. It is a synchronous and deterministic state machine built using Angular signals for reactive state updates.

## Core Files

- `engine.model.ts` - Type definitions for engine state, events, and listeners.
- `effects/` - Implementation of passive effect listeners (conditions, durations, instances) and the `ListenerFactory`.
- `processors.ts` - Implementation of all atomic effect processors.
- `engine.ts` - Core engine logic, event processing loop, and state management.
- `index.ts` - Public exports for the engine module.

## Key Concepts

**EngineState**: An immutable snapshot of the game state, containing state for both players and active listeners.

**GameEvent**: A unified representation of game actions, including lifecycle events (`on_play`, `on_turn_end`) and atomic effects (damage, healing, etc.).

**Listeners**: Reactive components that process `GameEvent`s in LIFO (Last-In-First-Out) order. A listener can:

- Return the event unchanged.
- Modify the event.
- Consume the event (stop propagation).
- Expand the event into multiple events.
  New events generated by a listener are processed by subsequent listeners only, preventing infinite loops.

The engine uses several specialized listener implementations:

- `DefaultPassiveInstance`: Generic listener that replaces events (for `before_effect` conditions) or adds additional events.
- `NegateListener`: Consumes triggering events entirely (e.g. negating damage).
- `InvertListener`: Modifies triggering events by inverting their value (e.g. converting damage to healing).

**EffectProcessors**: Pure functions that apply atomic effects to the `EngineState` once they have passed through all listeners.

## API (`Engine` Class)

### Initialization

**new Engine(playerOne: Loadout & { id: string }, playerTwo: Loadout & { id: string })**

- Initializes the engine with two player loadouts.
- Scans items for passive effects and registers them as initial listeners.

### Actions

**play(playerId: string, itemId: ItemId): LogEntry[]**

- Retrieves the behavior for the given item.
- Removes the item from the player's inventory (one-time use).
- Processes all effects returned by the item's behavior.
- Updates the engine state reactively.
- Returns a log of all events, reactions, and processors triggered by the action.

**processEndOfTurn(playerId: string): LogEntry[]**

- Emits `on_turn_end` event to trigger reactive behaviors and lifecycle updates.
- Updates the engine state reactively.
- Returns a log of all events, reactions, and processors triggered by the end of turn.

### State Queries

- `state` - A computed signal returning the current `EngineState`.

## Supported Effects

- `damage`: Decreases the targeted player's health.
- `healing`: Increases the targeted player's health.
- `remove_item`: Removes an item from the targeted player's loadout and cleans up its passive effects.
- `add_passive_effect`: Adds a persistent passive effect (with its defined `Duration`) to the targeted player.

## Logging

The engine generates a log of all significant occurrences during event processing. This log is returned by the primary action methods (`play`, `processEndOfTurn`) and can be used by the UI to represent high-level game actions or for verification in integration tests.

The log contains three types of entries:

- `event`: High-level game events like `on_play`, `on_turn_end`, and initial effects triggered by items.
- `reaction`: Recorded when a `Listener` modifies, consumes, or expands an event.
- `processor`: Recorded when an atomic effect is finally applied to the state by a processor.

## Implementation Notes

- The engine is deterministic and side-effect free.
- State updates are immutable.
- Effect processing is recursive, allowing high-level effects to resolve into low-level ones.
- The engine only depends on the `item` module.
