# Engine Module - Agent Documentation

## Overview

The core game engine that manages the game state and flow. It is a synchronous and deterministic state machine built using Angular signals for reactive state updates.

## Core Files

- engine.model.ts - Type definitions for engine state, events, and listeners.
- effects/ - Implementation of status and passive effect listeners:
  - passive/ - Listeners tied to an item's existence in the loadout.
  - status/ - Listeners tied to a duration (buffs/debuffs).
  - reactive-condition.ts - Shared trigger logic.
  - reactive-duration.ts - Shared duration logic.
  - ListenerFactory.ts - Factory for creating the appropriate listener instance.
- processors.ts - Implementation of all atomic effect processors.
- turn-manager.ts - Infinite turn sequence generator based on player speed.
- engine.ts - Core engine logic, event processing loop, and state management.
- index.ts - Public exports for the engine module.

## Key Concepts

**EngineState**: An immutable snapshot of the game state, containing state for both players and active listeners. The `turnQueue` inside the state is now a list of `TurnEntry`s coming directly from `TurnManager`, so downstream consumers (Board/UI) get both the `playerId` and stable `id` for animation tracking. It also carries terminal game information:

- `gameOver: boolean` - set to `true` when the game is over
- `winnerId?: string` - the winner's player ID when `gameOver` is `true`

**GameEvent**: A unified representation of game actions, including lifecycle events (`on_play`, `on_turn_start`, `on_turn_end`, `game_start`), wrapped atomic effects, and terminal events (`game_over`).

- Lifecycle: `{ type: 'lifecycle', playerId, phase }`
- On Play: `{ type: 'on_play', playerId, itemId }`
- Effect: `{ type: 'effect', effect: Effect, playerId }` - all atomic effects (e.g., `damage`, `healing`, `remove_item`, `remove_listener`) are carried inside the `effect` field.

**Listeners**: Reactive components that process `GameEvent`s in LIFO (Last-In-First-Out) order. A listener can:

- Return the event unchanged.
- Modify the event.
- Consume the event (stop propagation).
- Expand the event into multiple events.

New events generated by a listener are processed by subsequent listeners only, preventing infinite loops. Listeners are explicitly removed from the state when they emit a `remove_listener` event.

The engine uses a hierarchy of listener implementations based on `BaseEffectInstance`:

- `BasePassiveInstance`: Abstract base for listeners tied to an item's existence in the loadout. It automatically emits `remove_listener` if it detects its parent item is removed.
- `BaseStatusEffectInstance`: Abstract base for listeners tied to a duration. It automatically emits `remove_listener` when its `duration` expires.
- `DefaultPassiveInstance`: A concrete implementation of `BasePassiveInstance` that uses standard reaction logic (adding or replacing effects).
- `DefaultStatusEffectInstance`: A concrete implementation of `BaseStatusEffectInstance` that uses standard reaction logic.
- `NegateListener`: Consumes triggering events entirely (e.g. negating damage). Inherits from `BaseStatusEffectInstance`.
- `InvertListener`: Modifies triggering events by inverting their value (e.g. converting damage to healing). Inherits from `BaseStatusEffectInstance`.
- `FatigueListener`: Applies damage to the player at the end of their turn if they have no items. Inherits from `BaseStatusEffectInstance`.
- `ReactiveRemovalListener`: Removes its parent item from the loadout when triggered. Inherits from `BasePassiveInstance`.

**EffectProcessors**: Pure functions that apply atomic effects to the `EngineState` once they have passed through all listeners.

## API (`Engine` Class)

### Initialization

**new Engine(playerOne: Loadout & { id: string }, playerTwo: Loadout & { id: string })**

- Initializes the engine with two player loadouts.
- Scans items for passive effects and registers them as initial listeners.

### Actions

**play(playerId: string, itemId: ItemId): void**

- Retrieves the behavior for the given item.
- Removes the item from the player's inventory (one-time use).
- Processes all effects returned by the item's behavior.
- Updates the engine state reactively.
- Adds log entries to the `EngineState`.

**processEndOfTurn(playerId: string): void**

- Emits `on_turn_end` event to trigger reactive behaviors and lifecycle updates.
- Updates the engine state reactively.
- Adds log entries to the `EngineState`.

**consumeLog(): LogEntry[]**

- Returns and clears all log entries from the current `EngineState`.

### State Queries

- `state` - A computed signal returning the current `EngineState`. `EngineState` includes a `log` array, `done` flag, and optional `winnerId`.

## Supported Effects

- `damage`: Decreases the targeted player's health.
- `healing`: Increases the targeted player's health.
- `speed_up`: Increases the targeted player's speed by the effect's value and immediately recalculates the turn queue.
- `slow_down`: Decreases the targeted player's speed by the effect's value and immediately recalculates the turn queue.
- `remove_item`: Removes an item from the targeted player's loadout. The processor also automatically removes any listeners associated with the removed item's `instanceId`. Listeners are still encouraged to emit `remove_listener` if they have complex cleanup, but for passive effects tied to item existence, it is handled by the processor.
- `remove_listener`: Explicitly removes a listener from the engine state by its `instanceId`.
- `add_status_effect`: Adds a persistent status effect (with its defined `Duration`) to the targeted player.

All processors for these effects now automatically append a `state-change` type entry (a full `EngineState` snapshot) to the engine's log.

### Speed Modification Effects

Speed changes (`speed_up` and `slow_down`) are permanent (do not expire) and immediately affect turn order:

- The processor updates the target player's `speed` attribute
- The `TurnManager.recalculateTurnQueue()` function is called to rebuild the turn queue based on new speeds
- Speed modifications stack (multiple speed_up/slow_down effects add/subtract cumulatively)
- The `modifySpeed(value, target?)` factory function in the item module creates the appropriate effect based on sign (positive = speed_up, negative = slow_down)

## Logging

The engine maintains a log of all significant occurrences during event processing within its state. This log can be retrieved and cleared via `consumeLog()`.

The log contains three types of entries:

- `event`: High-level game events like `on_play`, `on_turn_start`, `on_turn_end`, `game_start`, wrapped `effect` events, and terminal `game_over`.
- `state-change`: Recorded when an atomic effect is finally applied to the state by a processor; contains a full `EngineState` snapshot.

## Implementation Notes

- The engine is deterministic.
- State updates are immutable for player attributes and items, though listeners are permitted to mutate their internal state (e.g., charges, duration) as an implementation detail.
- Effect processing is recursive, allowing high-level effects to resolve into low-level ones.
- The engine only depends on the `item` module.
- Processors hydrate and refresh a single `TurnManager` instance (with the raw `turnQueue`) before advancing turns or recalculating after speed changes, ensuring the queue always carries producer-generated `TurnEntry`s so UI-facing components can trust both the `playerId` and `id`.
- When any player's health drops to zero or below via a processed `damage` effect (including fatigue), the engine:
  - Appends an `event` log entry: `{ type: 'game_over', loserId, winnerId }`
  - Sets `state.gameOver = true` and `state.winnerId`
  - Ignores any subsequent events (no further processing or logging)

## Testing

Unit tests for the engine should verify that events are correctly processed, listeners are correctly added/removed, and processors correctly mutate the state. Testing of listener logic is encouraged here.
